import unittest
import os
import sys
import json
from unittest.mock import patch, MagicMock, AsyncMock
from lxml import etree

from src.despatch.despatchCreate import (
    addDespatchAdvice,
    getDespatchAdvice,
    generate_initial_xml,
    create_despatch_advice,
    validate_despatch_advice,
    get_despatch_xml,
    update_despatch_advice,
    delete_despatch_advice,
)

dirPath = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
sys.path.append(dirPath)


class TestDespatchCreate(unittest.IsolatedAsyncioTestCase):
    async def asyncSetUp(self):
        self.valid_despatch_data = {
            "DespatchID": "D-12345678",
            "UUID": "660e8400-e29b-41d4-a716-446655440001",
            "OrderID": "ORD-12345",
            "Status": "Initiated",
            "SupplierInfo": {
                "is_seller": True,
                "name": "Supplier Co.",
                "contact": "John Smith",
            },
            "CustomerInfo": {
                "id": "CUST-001",
                "details": {"name": "Customer Ltd.", "address": "123 Main St"},
            },
            "CreationDate": "2025-03-16",
            "XMLData": "<DespatchAdvice>...</DespatchAdvice>",
            "LastModified": "2025-03-16T10:00:00",
        }

        self.valid_event_body = {
            "order_id": "ORD-12345",
            "supplier": {
                "is_seller": True,
                "name": "Supplier Co.",
                "contact": "John Smith",
            },
            "customer": {
                "id": "CUST-001",
                "details": {"name": "Customer Ltd.", "address": "123 Main St"},
            },
        }

        self.sample_order = {
            "OrderID": "ORD-12345",
            "UUID": "550e8400-e29b-41d4-a716-446655440000",
            "CustomerID": "CUST-001",
            "Items": [
                {"item_id": "ITEM-001", "quantity": 5, "price": 10.5},
                {"item_id": "ITEM-002", "quantity": 3, "price": 15.75},
            ],
            "Status": "Created",
            "CreationDate": "2025-03-15T10:00:00",
            "LastModified": "2025-03-15T10:00:00",
        }

        self.sample_xml = """<?xml version="1.0" encoding="UTF-8"?>
<DespatchAdvice
    xmlns="urn:oasis:names:specification:ubl:schema:xsd:DespatchAdvice-2"
        xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"
        xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">
    <cbc:UBLVersionID>2.0</cbc:UBLVersionID>
    <cbc:CustomizationID>urn:oasis:names:specification:ubl:schema:xsd:DespatchAdvice-2.0:sbs-1.0-draft</cbc:CustomizationID>
    <cbc:ProfileID>bpid:oasis:names:draft:bpss:ubl-2-sbs-despatch-advice-notification-draft</cbc:ProfileID>
    <cbc:ID>D-12345678</cbc:ID>
    <cbc:CopyIndicator>false</cbc:CopyIndicator>
    <cbc:UUID>660e8400-e29b-41d4-a716-446655440001</cbc:UUID>
    <cbc:IssueDate>2025-03-16</cbc:IssueDate>
    <cbc:DocumentStatusCode>NoStatus</cbc:DocumentStatusCode>
    <cbc:DespatchAdviceTypeCode>delivery</cbc:DespatchAdviceTypeCode>
    <cbc:Note>Generated by Despatch Advice Generator</cbc:Note>
</DespatchAdvice>"""

        self.valid_despatch_data["XMLData"] = self.sample_xml

        # Use AsyncMock instead of MagicMock for coroutine behavior
        self.client = MagicMock()
        self.db = MagicMock()

        # Set up db mock with despatches collection using AsyncMock
        self.db.despatches = MagicMock()
        self.db.despatches.find_one = AsyncMock()
        self.db.despatches.insert_one = AsyncMock()
        self.db.despatches.update_one = AsyncMock()
        self.db.despatches.delete_one = AsyncMock()

    async def asyncTearDown(self):
        if hasattr(self, "client") and hasattr(self.client, "close"):
            self.client.close()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.addOrder", new_callable=AsyncMock)
    async def test_add_despatch_advice_success(self, mock_add_order, mock_db_connect):
        mock_db_connect.return_value = (self.client, self.db)
        mock_add_order.return_value = "inserted_id"

        result = await addDespatchAdvice(self.valid_despatch_data)

        self.assertEqual(result, "inserted_id")
        mock_db_connect.assert_called_once()
        mock_add_order.assert_called_once_with(self.valid_despatch_data, self.db)
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.addOrder", new_callable=AsyncMock)
    async def test_add_despatch_advice_failure(self, mock_add_order, mock_db_connect):
        mock_db_connect.return_value = (self.client, self.db)
        mock_add_order.side_effect = Exception("Database error")

        result = await addDespatchAdvice(self.valid_despatch_data)

        self.assertIsNone(result)
        mock_db_connect.assert_called_once()
        mock_add_order.assert_called_once()
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    async def test_get_despatch_advice_success(self, mock_db_connect):
        mock_db_connect.return_value = (self.client, self.db)

        # Setup the find_one mock to return our data
        self.db.despatches.find_one.return_value = self.valid_despatch_data

        result = await getDespatchAdvice("D-12345678")

        self.assertEqual(result, self.valid_despatch_data)
        mock_db_connect.assert_called_once()
        self.db.despatches.find_one.assert_called_once_with(
            {"DespatchID": "D-12345678"}
        )
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    async def test_get_despatch_advice_by_uuid(self, mock_db_connect):
        mock_db_connect.return_value = (self.client, self.db)

        # First call returns None, second call returns data (UUID fallback)
        self.db.despatches.find_one.side_effect = [None, self.valid_despatch_data]

        result = await getDespatchAdvice("660e8400-e29b-41d4-a716-446655440001")

        self.assertEqual(result, self.valid_despatch_data)
        self.assertEqual(mock_db_connect.call_count, 1)
        self.assertEqual(self.db.despatches.find_one.call_count, 2)
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    async def test_get_despatch_advice_failure(self, mock_db_connect):
        mock_db_connect.return_value = (self.client, self.db)

        # Setup the find_one mock to throw an exception
        self.db.despatches.find_one.side_effect = Exception("Database error")

        result = await getDespatchAdvice("D-12345678")

        self.assertIsNone(result)
        mock_db_connect.assert_called_once()
        self.db.despatches.find_one.assert_called_once()
        self.client.close.assert_called_once()

    @patch("uuid.uuid4")
    async def test_generate_initial_xml(self, mock_uuid):
        mock_uuid.return_value = "660e8400-e29b-41d4-a716-446655440001"

        result = generate_initial_xml("D-12345678", "2025-03-16")

        self.assertIsInstance(result, str)

        try:
            root = etree.fromstring(result.encode("utf-8"))
            self.assertIsNotNone(root)
        except Exception as e:
            self.fail(f"Failed to parse XML: {str(e)}")

        self.assertIn("<cbc:ID>D-12345678</cbc:ID>", result)
        self.assertIn("<cbc:IssueDate>2025-03-16</cbc:IssueDate>", result)
        self.assertIn(
            "<cbc:DocumentStatusCode>NoStatus</cbc:DocumentStatusCode>", result
        )
        self.assertIn(
            "<cbc:DespatchAdviceTypeCode>" "delivery" "</cbc:DespatchAdviceTypeCode>",
            result,
        )

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getOrderInfo", new_callable=AsyncMock)
    @patch("uuid.uuid4")
    @patch("datetime.datetime")
    async def test_create_despatch_advice_success(
        self, mock_datetime, mock_uuid, mock_get_order, mock_db_connect
    ):
        mock_now = MagicMock()
        mock_now.strftime.return_value = "2025-03-16"
        mock_now.isoformat.return_value = "2025-03-16T10:00:00"
        mock_datetime.now.return_value = mock_now

        # Setup UUID mocks to avoid hex attribute issues
        random_uuid = MagicMock()
        random_uuid.hex = "12345678"
        mock_uuid.return_value = random_uuid

        mock_db_connect.return_value = (self.client, self.db)
        mock_get_order.return_value = self.sample_order

        # Set up the insert_one mock to return a
        # result with successful inserted_id
        insert_result = MagicMock()
        insert_result.inserted_id = "mock_id"
        self.db.despatches.insert_one.return_value = insert_result

        result = await create_despatch_advice(self.valid_event_body)

        self.assertEqual(result["statusCode"], 200)
        response_body = json.loads(result["body"])
        self.assertIn("despatch_id", response_body)
        self.assertEqual(response_body["status"], "Initiated")
        self.assertIn("xml_link", response_body)

        mock_db_connect.assert_called_once()
        mock_get_order.assert_called_once_with("ORD-12345", self.db)
        self.db.despatches.insert_one.assert_called_once()
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getOrderInfo", new_callable=AsyncMock)
    async def test_create_despatch_advice_missing_order_id(
        self, mock_get_order, mock_db_connect
    ):
        invalid_event_body = {
            "supplier": self.valid_event_body["supplier"],
            "customer": self.valid_event_body["customer"],
        }

        result = await create_despatch_advice(invalid_event_body)

        self.assertEqual(result["statusCode"], 400)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("missing order_id", response_body["error"])

        mock_db_connect.assert_not_called()
        mock_get_order.assert_not_called()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getOrderInfo", new_callable=AsyncMock)
    async def test_create_despatch_advice_order_not_found(
        self, mock_get_order, mock_db_connect
    ):
        mock_db_connect.return_value = (self.client, self.db)
        mock_get_order.return_value = None

        result = await create_despatch_advice(self.valid_event_body)

        self.assertEqual(result["statusCode"], 404)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Order does not exist")

        mock_db_connect.assert_called_once()
        mock_get_order.assert_called_once_with("ORD-12345", self.db)
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getOrderInfo", new_callable=AsyncMock)
    @patch("uuid.uuid4")
    @patch("datetime.datetime")
    async def test_create_despatch_advice_db_failure(
        self, mock_datetime, mock_uuid, mock_get_order, mock_db_connect
    ):
        mock_now = MagicMock()
        mock_now.strftime.return_value = "2025-03-16"
        mock_now.isoformat.return_value = "2025-03-16T10:00:00"
        mock_datetime.now.return_value = mock_now

        # Setup UUID mocks properly
        random_uuid = MagicMock()
        random_uuid.hex = "12345678"
        mock_uuid.return_value = random_uuid

        mock_db_connect.return_value = (self.client, self.db)
        mock_get_order.return_value = self.sample_order

        # Make the insert operation fail
        insert_result = None
        self.db.despatches.insert_one.return_value = insert_result

        result = await create_despatch_advice(self.valid_event_body)

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Failed to create despatch advice")

        mock_db_connect.assert_called_once()
        mock_get_order.assert_called_once()
        self.db.despatches.insert_one.assert_called_once()
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getOrderInfo", new_callable=AsyncMock)
    async def test_create_despatch_advice_exception(
        self, mock_get_order, mock_db_connect
    ):
        mock_db_connect.side_effect = Exception("Test database exception")

        result = await create_despatch_advice(self.valid_event_body)

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("Server error", response_body["error"])

        mock_db_connect.assert_called_once()
        mock_get_order.assert_not_called()

    # New tests for validate_despatch_advice
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_validate_despatch_advice_invalid_xml(self, mock_get_despatch):
        # Create a despatch with invalid XML
        invalid_despatch = self.valid_despatch_data.copy()
        invalid_despatch["XMLData"] = "<invalid>XML<missing-close-tag>"

        mock_get_despatch.return_value = invalid_despatch

        result = await validate_despatch_advice("D-12345678")

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("Server error", response_body["error"])

        mock_get_despatch.assert_called_once_with("D-12345678")

    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_validate_despatch_advice_not_found(self, mock_get_despatch):
        # Setup mock to return None (despatch not found)
        mock_get_despatch.return_value = None

        result = await validate_despatch_advice("D-NONEXISTENT")

        self.assertEqual(result["statusCode"], 404)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Despatch Advice not found")

        mock_get_despatch.assert_called_once_with("D-NONEXISTENT")

    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_validate_despatch_advice_missing_required_elements(
        self, mock_get_despatch
    ):
        # Create a despatch with XML missing required elements
        incomplete_xml = """<?xml version="1.0" encoding="UTF-8"?>
        <DespatchAdvice
            xmlns="urn:oasis:names:specification:ubl:schema:xsd:DespatchAdvice-2"
            xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"
            xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">
            <!-- Missing ID and IssueDate -->
            <cbc:Note>Test note</cbc:Note>
        </DespatchAdvice>"""

        incomplete_despatch = self.valid_despatch_data.copy()
        incomplete_despatch["XMLData"] = incomplete_xml

        mock_get_despatch.return_value = incomplete_despatch

        result = await validate_despatch_advice("D-12345678")

        self.assertEqual(result["statusCode"], 200)
        response_body = json.loads(result["body"])
        self.assertEqual(response_body["validation_status"], "Invalid")
        self.assertIn("issues", response_body)
        self.assertGreaterEqual(len(response_body["issues"]), 1)

        mock_get_despatch.assert_called_once_with("D-12345678")

    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_validate_despatch_advice_missing_recommended_elements(
        self, mock_get_despatch
    ):
        # XML with required elements but missing recommended ones
        minimal_xml = """<?xml version="1.0" encoding="UTF-8"?>
        <DespatchAdvice
            xmlns="urn:oasis:names:specification:ubl:schema:xsd:DespatchAdvice-2"
            xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2"
            xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2">
            <cbc:ID>D-12345678</cbc:ID>
            <cbc:IssueDate>2025-03-16</cbc:IssueDate>
            <!-- Missing recommended elements: DespatchSupplierParty, DeliveryCustomerParty, Shipment -->
        </DespatchAdvice>"""

        minimal_despatch = self.valid_despatch_data.copy()
        minimal_despatch["XMLData"] = minimal_xml

        mock_get_despatch.return_value = minimal_despatch

        result = await validate_despatch_advice("D-12345678")

        self.assertEqual(result["statusCode"], 200)
        response_body = json.loads(result["body"])
        self.assertEqual(response_body["validation_status"], "Valid")
        self.assertNotIn("issues", response_body)
        self.assertIn("warnings", response_body)
        self.assertGreaterEqual(len(response_body["warnings"]), 1)

        mock_get_despatch.assert_called_once_with("D-12345678")

    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_validate_despatch_advice_exception(self, mock_get_despatch):
        mock_get_despatch.side_effect = Exception("Test exception")

        result = await validate_despatch_advice("D-12345678")

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("Server error", response_body["error"])

        mock_get_despatch.assert_called_once_with("D-12345678")

    # Tests for get_despatch_xml
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_get_despatch_xml_success(self, mock_get_despatch):
        mock_get_despatch.return_value = self.valid_despatch_data

        result = await get_despatch_xml("D-12345678")

        self.assertEqual(result["statusCode"], 200)
        self.assertEqual(result["headers"]["Content-Type"], "application/xml")
        self.assertEqual(result["body"], self.sample_xml)

        mock_get_despatch.assert_called_once_with("D-12345678")

    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_get_despatch_xml_not_found(self, mock_get_despatch):
        mock_get_despatch.return_value = None

        result = await get_despatch_xml("D-NONEXISTENT")

        self.assertEqual(result["statusCode"], 404)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Despatch Advice not found")

        mock_get_despatch.assert_called_once_with("D-NONEXISTENT")

    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_get_despatch_xml_exception(self, mock_get_despatch):
        mock_get_despatch.side_effect = Exception("Test exception")

        result = await get_despatch_xml("D-12345678")

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("Server error", response_body["error"])

        mock_get_despatch.assert_called_once_with("D-12345678")

    # Tests for update_despatch_advice
    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.updateDocument", new_callable=AsyncMock)
    @patch("datetime.datetime")
    async def test_update_despatch_advice_success(
        self, mock_datetime, mock_update_document, mock_get_despatch, mock_db_connect
    ):
        mock_now = MagicMock()
        mock_now.isoformat.return_value = "2025-03-16T11:00:00"
        mock_datetime.now.return_value = mock_now

        mock_db_connect.return_value = (self.client, self.db)
        mock_get_despatch.return_value = self.valid_despatch_data
        mock_update_document.return_value = True

        update_body = {"xml": self.sample_xml, "status": "Completed"}

        result = await update_despatch_advice("D-12345678", update_body)

        self.assertEqual(result["statusCode"], 200)
        response_body = json.loads(result["body"])
        self.assertEqual(response_body["despatch_id"], "D-12345678")
        self.assertEqual(response_body["status"], "Updated")

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_called_once_with("D-12345678")
        mock_update_document.assert_called_once()
        self.client.close.assert_called_once()

        # Verify update data contains correct fields
        update_data = mock_update_document.call_args[0][1]
        self.assertEqual(update_data["XMLData"], self.sample_xml)
        self.assertEqual(update_data["Status"], "Completed")
        self.assertEqual(update_data["LastModified"], "2025-03-16T11:00:00")

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_update_despatch_advice_missing_xml(
        self, mock_get_despatch, mock_db_connect
    ):
        invalid_body = {
            "status": "Completed"
            # Missing "xml" field
        }

        result = await update_despatch_advice("D-12345678", invalid_body)

        self.assertEqual(result["statusCode"], 400)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("missing xml field", response_body["error"])

        mock_db_connect.assert_not_called()
        mock_get_despatch.assert_not_called()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_update_despatch_advice_not_found(
        self, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.return_value = (self.client, self.db)
        mock_get_despatch.return_value = None

        update_body = {"xml": self.sample_xml, "status": "Completed"}

        result = await update_despatch_advice("D-NONEXISTENT", update_body)

        self.assertEqual(result["statusCode"], 404)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Despatch Advice not found")

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_called_once_with("D-NONEXISTENT")
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_update_despatch_advice_invalid_xml(
        self, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.return_value = (self.client, self.db)
        mock_get_despatch.return_value = self.valid_despatch_data

        update_body = {"xml": "<invalid>XML<missing-close-tag>", "status": "Completed"}

        result = await update_despatch_advice("D-12345678", update_body)

        self.assertEqual(result["statusCode"], 400)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("Invalid XML", response_body["error"])

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_called_once_with("D-12345678")
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.updateDocument", new_callable=AsyncMock)
    async def test_update_despatch_advice_update_failure(
        self, mock_update_document, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.return_value = (self.client, self.db)
        mock_get_despatch.return_value = self.valid_despatch_data
        mock_update_document.return_value = False  # Indicate update failure

        update_body = {"xml": self.sample_xml, "status": "Completed"}

        result = await update_despatch_advice("D-12345678", update_body)

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Failed to update despatch advice")

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_called_once_with("D-12345678")
        mock_update_document.assert_called_once()
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_update_despatch_advice_exception(
        self, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.side_effect = Exception("Test database exception")

        update_body = {"xml": self.sample_xml, "status": "Completed"}

        result = await update_despatch_advice("D-12345678", update_body)

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("Server error", response_body["error"])

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_not_called()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.deleteDocument", new_callable=AsyncMock)
    async def test_delete_despatch_advice_success(
        self, mock_delete_document, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.return_value = (self.client, self.db)
        mock_get_despatch.return_value = self.valid_despatch_data
        mock_delete_document.return_value = True

        result = await delete_despatch_advice("D-12345678")

        self.assertEqual(result["statusCode"], 200)
        response_body = json.loads(result["body"])
        self.assertEqual(response_body["despatch_id"], "D-12345678")
        self.assertEqual(response_body["status"], "Deleted")

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_called_once_with("D-12345678")
        mock_delete_document.assert_called_once_with("D-12345678", self.db)
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_delete_despatch_advice_not_found(
        self, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.return_value = (self.client, self.db)
        mock_get_despatch.return_value = None

        result = await delete_despatch_advice("D-NONEXISTENT")

        self.assertEqual(result["statusCode"], 404)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Despatch Advice not found")

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_called_once_with("D-NONEXISTENT")
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.deleteDocument", new_callable=AsyncMock)
    async def test_delete_despatch_advice_delete_failure(
        self, mock_delete_document, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.return_value = (self.client, self.db)
        mock_get_despatch.return_value = self.valid_despatch_data
        mock_delete_document.return_value = False  # Indicate delete failure

        result = await delete_despatch_advice("D-12345678")

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertEqual(response_body["error"], "Failed to delete despatch advice")

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_called_once_with("D-12345678")
        mock_delete_document.assert_called_once()
        self.client.close.assert_called_once()

    @patch("src.despatch.despatchCreate.dbConnect", new_callable=AsyncMock)
    @patch("src.despatch.despatchCreate.getDespatchAdvice", new_callable=AsyncMock)
    async def test_delete_despatch_advice_exception(
        self, mock_get_despatch, mock_db_connect
    ):
        mock_db_connect.side_effect = Exception("Test database exception")

        result = await delete_despatch_advice("D-12345678")

        self.assertEqual(result["statusCode"], 500)
        response_body = json.loads(result["body"])
        self.assertIn("error", response_body)
        self.assertIn("Server error", response_body["error"])

        mock_db_connect.assert_called_once()
        mock_get_despatch.assert_not_called()


if __name__ == "__main__":
    unittest.main()
